---
title: "WordleR Performance Analysis (aka 'Autoplayer')"
author: "John Erickson"
date: "1/22/2022"
output: html_document
---

```{r setup, include=FALSE}
library(tidyverse)
# library(foreach)
# library(doParallel)
# 
# numCores <- detectCores()
# numCores

knitr::opts_chunk$set(echo = TRUE)
```

## The Challenge: Are there any Wordle puzzles that WordleR can't find?

There are many possible word lists, from Knuth (5757 words) to Kaggle (over 39k). Ultimately we found the list of 2315 Wordle "Magic Words..."

Our default is to load the Wordle Magic Word list, arranged by the frequency of letters in each word and de-emphasizing duplicate letters. Other word list options are available for testing and analysis. 

```{r}
# The usual setup
# Initialize our word list
#unigram_freq <- readRDS("unigram_freq.Rds") # From Kaggle
#short_list.df <- unigram_freq
#short_list.df <- readRDS("short_list.Rds") # Knuth's 5757 words, sorted by frequency
short_list.df <- readRDS("Wordle_Words.Rds") # DEFAULT: Load "official" Wordle Magic Words

# # NEW: Re-arrange short-list based on letter frequency!
# # Only do once, when initializing a new word list (e.g. Wordle words)
# short_list.df$score <- NA
# 
# for (test in short_list.df$word) {
#   # De-emphasize duplicate letters!!!
#   test_vect <- unique(strsplit(test,"")[[1]])
#   score <- 0
#   for (test_letter in test_vect) {
#     letter_score <- letter_freq$freq[which(letter_freq$letter == test_letter)]
#     score <- score + letter_score
#   }
#   short_list.df$score[short_list.df$word==test] <- score
# }
# # Re-arrange
# short_list.df <- short_list.df %>% arrange(desc(score))
# # Save the re-ordered Wordle list
# saveRDS(short_list.df, "Wordle_Words.Rds")

# select the top n words by frequency from the selected word list
n <- nrow(short_list.df)

short_list <- short_list.df[1:n,]$word

# Initialize some useful potential starter words, for analysis
trial_words <- c("bayou","audio","equal",
                 "ouija","adieu",
                 "noisy","ousia","miaou")
```

## The Challenge

**Overview:** For each recommended WordleR "starter word," verify that any other word on the `short_list` can be reached by the WordleR "algorithm."

**WordleR "Manual" Algorithm:**

Assumes a word list (challenge words and potential guesses) arranged by scoring the word frequency of each letter of each word, and not scoring for multiple occurrences of a letter. 

1. Select a starter word, for example one of `r trial_words`. 
   * After many test runs, we usually just use **BAYOU** 
2. Get Wordle's response:
   * Letters to exclude (grey squares)
   * Letters to include (yellow or green squares)
   * Letters to exclude by position (yellow)
   * Letters to include by position (green)
3. Modify the word list based on these results to reveal the remaining possible words. By pre-arranging the word list based on the frequency of each letter, we hope to increase the amount of "information" returned by Wordle for each of our guesses. 
4. Select WordleR's top recommendation and submit to Wordle. 

**WordleR "Autoplay" Algorithm:**

For each starter word from `r trial_words`:

1. The `starter` word is the first `test` word in the outer loop (could be manual)
2. Select the next `challenge` word from `short_list` (emulates Wordle's hidden word)
3. Evaluate `test` against the current `challenge`:
   * Letters to exclude: What letters aren't present at all?
   * Letters to include: What letters are present
   * Letters to exclude by position: What letters don't match, by position?
   * Letters to include by position: What letters are perfect matches, by position?
   * Update our data structure holding the results needed to guide our exclusion and inclusion steps.
3. Modify the word list based on these results to reveal the remaining possible words. 
   * By pre-arranging the word list based on the frequency of each letter, we hope to increase the amount of "information" returned by Wordle for each of our guesses. 
5. Select the top word (first word in the remaining list) as the new test word
6. Repeat until `test` matches a member of `short_list` or the end of `short_list` is reached. 

##Exclusion/Inclusion Functions

These implement the WordleR exclude/exclude buttons...

```{r}
# Filter a list of words based on a letter to exclude
exclude_letter <- function(letter,word_list) {
    exclude_mask <- !grepl(letter, word_list, fixed = TRUE)
    return(word_list[exclude_mask])
}

# Filter a list of words based on a letter to include
include_letter <- function(letter,word_list) {
    include_mask <- grepl(letter, word_list, fixed = TRUE)
    return(word_list[include_mask])
}
  
exclude_letter_position <- function(letter,position,word_list){
    exclude_mask <- str_sub(word_list, position, position) != letter
    return(word_list[exclude_mask])
}
  
include_letter_position <- function(letter,position,word_list) {
    include_mask <- str_sub(word_list, position, position) == letter
    return(word_list[include_mask])
}


# Filter a list of words based on a list of letters to exclude
exclude_letters <- function(letter_list,word_list) {
  result <- word_list
  for (letter in letter_list) {
    result <- exclude_letter(letter,result)
  }
  return(result)
}

# Filter a list of words based on a list of letters to include
include_letters <- function(letter_list,word_list) {
  result <- word_list
  for (letter in letter_list) {
    result <- include_letter(letter,result)
  }
  return(result)
}

```

##Wordle Tester

This returns a list containing the equivalent of Wordle's evaluation of our attempt: Letters to exclude or include, and positions when appropriate.

```{r}

word_test <- function(test,challenge) {
  
  test <- strsplit(test,"")[[1]]
  challenge <- strsplit(challenge,"")[[1]]
  
  # letters in `test` that are not in `challenge`
  no_match <- test[!(test == challenge)]
   
  # letters in `test` that are also in `challenge`
  match <- test[(test == challenge)]
  
  # letter/position matching
  # These are perfect matches
  match_mask <- test == challenge  # TRUEs are "green"
  not_match_mask <- test != challenge  # TRUEs are "green"

  # What letters/positions should be "green"?
  green_match <- test[match_mask] # green letters
  green_match_pos <- which(match_mask)
  
  # What letters/positions should be "yellow"?
  yellow_match <- test[not_match_mask] # green letters
  yellow_match_pos <- which(not_match_mask)
  
  # for (letter in yellow_match ) {
  #   letter_pos <- which(test == letter)
  #   yellow_match_pos <- c(yellow_match_pos, letter_pos)
  # }
  
  result <- list(no_match,match,green_match,green_match_pos,yellow_match,yellow_match_pos)
  
  return(result)
}

```

## Run the WordleR algorithm

* Test our guess (`attempt`) against the `challenge` word (the selected word from the list)
* Get the Wordle evaluation
* If the evaluation is a perfect match, exit!
* If not, use the evaluation to trim the list
* Refresh the `attempt` word; use the first word in list of remaining possibilities
* Continue until we achieve a perfect match

```{r message=FALSE, results='hide'}
#registerDoParallel(numCores)  

iteration_results <- data.frame(starter=character(),
                                challenge=character(),
                                iteration=integer())
```

```{r message=FALSE, results='hide'}

# Test against a list of potential starter words. 
for (starter in trial_words) {

# k is the range of challenge words we test against
for (k in 1:length(short_list)) {
challenge <- short_list[k]

# Re-initialize for next challenge word  
iteration <- as.integer(0)
word_list <- short_list
attempt <- starter  # Our first `attempt` is always our `starter` word

# Execute the WordleR algorithm
# `attempt` is the first entry in what remains of `word_list`
while ((length(word_list) != 0) && (!is.na(attempt) && (attempt != challenge))) {
  iteration <- as.integer(iteration + 1)

  # This is the Wordle evaluation!
  wordle_result <- word_test(attempt, challenge)
  
  # Exclude
  if (length(wordle_result[[1]])!=0)  {
    # Don't remove letters that are also includes
    # Use our own function to do the work!
     if (length(wordle_result[[2]])!=0){
       # Remove included letters from exclude list, if any 
       exclude_list <- exclude_letters(wordle_result[[2]],wordle_result[[1]])
     } else {
       # Otherwise, the list is okay
       exclude_list <- wordle_result[[1]]
     }
    word_list <- exclude_letters(exclude_list,word_list)
  }
  
  # Include
  if (length(wordle_result[[2]])!=0){
    word_list <- include_letters(wordle_result[[2]],word_list)
  }

  # Include by position 
  if (length(wordle_result[[3]])!=0){
    for (letter in wordle_result[[3]]){
      letter_pos <- which(strsplit(attempt,"")[[1]] == letter)[1]
      word_list <- include_letter_position(letter,letter_pos,word_list)
    }
  }

  # Exclude by position
  if (length(wordle_result[[5]])!=0){
    for (letter in wordle_result[[5]]){
      letter_pos <- which(strsplit(attempt,"")[[1]] == letter)[1]
      word_list <- exclude_letter_position(letter,letter_pos,word_list)
    }
  }
  
  # Choose the next attempt from the remains of `word_list
  # NOTE: word_list pre-arranged by letler frequency score
  if (length(word_list) != 0) { 
    attempt <- word_list[1]
  } else {
#    print("Error!")
  }
}

iteration_results <- rbind(iteration_results,cbind(starter,challenge,iteration=iteration+1)) %>%
  mutate(iteration = as.integer(iteration))

} # end of challenge list
} # end of starter list

iteration_results$starter <- as.factor(iteration_results$starter)
#stopImplicitCluster()
```

## The Bottom Line!

```{r}
# Aggregate the results

iteration_results_misses <- iteration_results %>% 
#  filter(starter=="bayou") %>% # In case we want results for one word
  filter(iteration > 6)

iteration_results_misses 
missed_words <- iteration_results[iteration_results$iteration > 6,]

write_csv(missed_words,"missed_words_2315.csv")

# What starter words win the most? (ie six iterations or less)
# Filter by iterations
iteration_results_wins <- iteration_results %>% 
  filter(iteration <= 6)

iteration_results_summary <- iteration_results_wins %>%
  group_by(starter, as.factor(iteration)) %>%
  summarise(n=n())

iteration_results_starter_success <- iteration_results_summary %>%
  group_by(starter) %>%
  summarise(iteration_total = sum(n)) %>%
  arrange(desc(iteration_total))

# Re-write our trial_words based on top test results
#trial_words <- iteration_results_starter_success$starter[1:20]
```


```{r}
iteration_results %>% 
#  filter(starter=="bayou") %>%
ggplot(aes(iteration, fill=starter)) + 
#  geom_histogram(stat = "count",fill="#6aa84f") + 
  geom_bar(stat = "count",position = position_dodge()) + 
  xlab("Iterations Required") + 
  scale_x_discrete(limits=c(1,2,3,4,5,6,7,8,9,10)) +
  scale_y_continuous(trans='log10') +
  ylab("Wordle Puzzles Solved") +
  labs(
  title = "Iterations required by WordleR Algorithm to solve Wordle puzzles",
#  subtitle = "Starter word: bayou",
  caption = "Based on the 2315-element Wordle 'Magic Words' list\nVisit WordleR at: http://bit.ly/WordleR")
``` 


```{r}
p <- as.data.frame(iteration_results) %>%
    # filter(starter!="ouija") %>%
    # filter(starter!="louie") %>%
    # filter(starter!="adieu") %>%
ggplot(aes(iteration,color=starter)) + 
  geom_density(stat = "count") + 
  xlab("Iterations Required") + 
  scale_x_discrete(limits=c(1,2,3,4,5,6,7,8,9,10)) +
  scale_y_continuous(trans='log10') +
  ylab("Wordle Puzzles Solved") +
  labs(
  title = "Iterations required by WordleR Algorithm to solve Wordle puzzles",
  subtitle = "Comparing four-vowel starter words",
  caption = "Based on the 2315-element Wordle 'Magic Words' list\nVisit WordleR at: http://bit.ly/WordleR") + 
#  caption = "Based on the top 3000 words on the 5757-word Knuth most-frequent-word list\nVisit WordleR at: http://bit.ly/WordleR") + 
  geom_vline(xintercept = 6)

ggsave(plot=p,filename = "4_vowel_starter_words.png")
p
```

##Test new approaches to ranking

```{r}
letter_freq <- readRDS("letter_freq.Rds")

test_list <- c("about","other","which","their","there","first",
               "would","these","click","price","state","email",
               "world","music","after","video","where","books",
               "links","years","order","items","group","under",
               "games","could","great","hotel","store","terms",
               "right","local","those","using","phone","forum",
               "based","black","check","index","being","women",
               "today","south","pages","found","house","photo")

test_list.df <- data.frame(word=test_list, score=NA)

for (test in test_list) {
  test_vect <- strsplit(test,"")[[1]]
  score <- 0
  for (test_letter in test_vect) {
    letter_score <- letter_freq$freq[which(letter_freq$letter == test_letter)]
    score <- score + letter_score
  }
  test_list.df$score[test_list.df$word==test] <- score
}

test_list.df <- test_list.df %>% arrange(desc(score))

attempt <- "bayou"

# Based on edit distance
  if (length(test_list) != 0) { 
    rank <- which(stringdist(attempt,test_list)== max(stringdist(attempt,test_list)))[1]
    attempt <- test_list[rank]
  } 

attempt

# scoring letter frequency 

```